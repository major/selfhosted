# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Repository Overview

This is a **Flux GitOps repository** for managing Kubernetes applications in a selfhosted cluster. Flux v2.7.1 continuously monitors this repository and automatically applies changes to the cluster.

All applications are deployed under the **`*.amajor.cloud`** domain and use **Nginx Ingress Controller** with automatic TLS certificate management via **Cert-manager** using Let's Encrypt HTTP-01 challenge.

## Architecture

### GitOps Structure

The repository follows Flux's standard GitOps pattern:

- **[clusters/selfhosted/](clusters/selfhosted/)** - Cluster-specific configuration
  - [flux-system/](clusters/selfhosted/flux-system/) - Flux core components and sync configuration (auto-generated by Flux)
  - [bootstrap.yaml](clusters/selfhosted/bootstrap.yaml) - Kustomization for bootstrap infrastructure (sealed-secrets)
  - [cert-manager.yaml](clusters/selfhosted/cert-manager.yaml) - Kustomization for cert-manager (TLS certificate management)
  - [infra.yaml](clusters/selfhosted/infra.yaml) - Kustomization for infrastructure apps (nginx-ingress)
  - [apps.yaml](clusters/selfhosted/apps.yaml) - Kustomization for application manifests

- **[apps/bootstrap-infra/](apps/bootstrap-infra/)** - Bootstrap infrastructure components
  - [sealed-secrets/](apps/bootstrap-infra/sealed-secrets/) - Encrypted secrets management (deployed first)

- **[apps/infra/](apps/infra/)** - Infrastructure applications
  - [cert-manager/](apps/infra/cert-manager/) - Cert-manager for TLS certificate automation
  - [nginx-ingress/](apps/infra/nginx-ingress/) - Nginx Ingress Controller
  - [flux-notifications/](apps/infra/flux-notifications/) - Discord notifications for Flux events

- **[apps/base/](apps/base/)** - Application manifests organized by application name
  - [flux-webhook/](apps/base/flux-webhook/) - GitHub webhook receiver for instant reconciliation
  - [uptime-kuma/](apps/base/uptime-kuma/) - Uptime monitoring service (with persistent storage)
  - [speedtest/](apps/base/speedtest/) - LibreSpeed speed test service
  - [tickerlake/](apps/base/tickerlake/) - Ticker application
  - [hvcwatch/](apps/base/hvcwatch/) - HVC watch service (with encrypted secrets)
  - [stockchartsalerts/](apps/base/stockchartsalerts/) - Stock chart alerts (with encrypted secrets)

### Flux Sync Flow

1. Flux GitRepository watches the `main` branch at `ssh://git@github.com/major/selfhosted`
2. `flux-system` Kustomization syncs `./clusters/selfhosted` every 10 minutes (or immediately via webhook)
3. `bootstrap-infra` Kustomization syncs `./apps/bootstrap-infra` (sealed-secrets) - **deployed first**
4. `cert-manager` Kustomization syncs `./apps/infra/cert-manager` - depends on bootstrap-infra, includes health checks
5. `infra` Kustomization syncs `./apps/infra/nginx-ingress` - depends on cert-manager
6. `apps` Kustomization syncs `./apps/base` (applications) - depends on infra
7. Changes to any YAML files trigger automatic reconciliation
8. **GitHub webhook** (configured at `flux-webhook.amajor.cloud`) triggers immediate reconciliation on push events

**Dependency Chain:**
```
bootstrap-infra (sealed-secrets)
    ↓
cert-manager (with health checks on 3 deployments)
    ↓
infra (nginx-ingress + flux-notifications)
    ↓
apps (all applications)
```

## Git Workflow

⚠️ **All changes MUST go through feature branches and pull requests.**

### Branch Strategy

- **NEVER push directly to `main`** unless explicitly requested by the user
- Create a feature branch for all changes (e.g., `feat/add-new-app`, `fix/update-deployment`)
- Open a pull request for review before merging to `main`
- The user will handle final git operations (push, merge, etc.)

### Workflow for Changes

1. Create a feature branch from `main`
2. Make changes to manifests
3. Validate changes locally (see [Validation](#validation))
4. Commit changes to the feature branch
5. Open a pull request targeting `main`
6. User reviews and merges the PR

### Why PRs Matter for GitOps

Since Flux automatically deploys everything merged to `main`, PRs provide:
- **Review gate** before changes hit the cluster
- **Validation opportunity** to catch misconfigurations
- **Audit trail** of what changed and why
- **Rollback reference** if something goes wrong

## Working with Applications

### Adding a New Application

1. Create a new directory under [apps/base/](apps/base/) with the application name
2. Add Kubernetes manifests (Deployment, Service, PVC, etc.)
3. Create a `kustomization.yaml` file listing all resources
4. For web applications, create an Ingress resource with:
   - Host: `<app-name>.amajor.cloud`
   - IngressClassName: `nginx`
   - Cert-manager annotation: `cert-manager.io/cluster-issuer: letsencrypt-production`
   - TLS secretName for automatic certificate management
5. Create a feature branch and open a PR (see [Git Workflow](#git-workflow))
6. After PR is merged, changes are applied immediately via webhook, or within 10 minutes via polling
7. To force immediate sync: `flux reconcile kustomization apps`

**NEVER USE BITNAMI HELM TEMPLATES. NEVER.**

### Example Ingress Configuration

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: example
  namespace: example
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-production
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - example.amajor.cloud
      secretName: example-tls  # Cert-manager will create this automatically
  rules:
    - host: example.amajor.cloud
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: example
                port:
                  number: 80
```

### Modifying Existing Applications

1. Create a feature branch from `main`
2. Edit manifests in the respective [apps/base/\<app-name\>/](apps/base/) directory
3. Validate and open a PR (see [Git Workflow](#git-workflow))
4. After PR is merged, changes are automatically applied immediately (via webhook) or on the next Flux sync interval (polling)

### Testing Changes

```bash
# Check Flux reconciliation status
flux get kustomizations

# Force reconciliation without waiting
flux reconcile kustomization apps

# View application status
flux get helmreleases
flux get all -A

# Check for errors
flux logs --level=error
```

## Key Commands

### Kubeconfig
- Use the kubeconfig at `~/.kube/k3s-psychz-config` for kubectl commands
- Set `KUBECONFIG=~/.kube/k3s-psychz-config` or use `--kubeconfig ~/.kube/k3s-psychz-config`

### Flux Operations

```bash
# Check Flux system health
flux check

# View all Flux resources
flux get sources git
flux get kustomizations

# Suspend/resume reconciliation (useful during maintenance)
flux suspend kustomization apps
flux resume kustomization apps

# Force reconciliation
flux reconcile kustomization flux-system
flux reconcile kustomization apps
```

### Validation

```bash
# Validate Kubernetes manifests before committing
kubectl --kubeconfig ~/.kube/k3s-psychz-config apply --dry-run=client -f apps/base/<app-name>/

# Validate with kustomize
kustomize build apps/base/
```

## TLS Certificate Management

TLS certificates are managed by **Cert-manager** using Let's Encrypt with HTTP-01 challenge validation.

### Architecture

1. **Cert-manager** ([apps/infra/cert-manager/](apps/infra/cert-manager/)) handles certificate lifecycle
2. **Let's Encrypt HTTP-01 Challenge** - Cert-manager uses HTTP-01 validation via Nginx Ingress
3. **Automatic Issuance** - Certificates are automatically issued when Ingress resources are created
4. **Automatic Renewal** - Cert-manager renews certificates 30 days before expiry
5. **Per-Service Certificates** - Each service gets its own certificate stored in a TLS secret

### Certificate Configuration

- **ClusterIssuer**: `letsencrypt-production` (production) and `letsencrypt-staging` (testing)
- **Email**: `major@mhtx.net`
- **Challenge Type**: HTTP-01 via Nginx Ingress
- **Certificate Storage**: Kubernetes TLS secrets (e.g., `uptime-kuma-tls`)
- **Validation Method**: Let's Encrypt verifies ownership via HTTP challenge on port 80

### ClusterIssuers

Two ClusterIssuers are available:

- **letsencrypt-staging** - Use for testing (higher rate limits, untrusted certificates)
- **letsencrypt-production** - Use for production (lower rate limits, trusted certificates)

### How Certificates Work

1. When you create an Ingress with the `cert-manager.io/cluster-issuer` annotation, cert-manager detects it
2. Cert-manager creates a Certificate resource and initiates ACME challenge
3. Let's Encrypt sends an HTTP-01 challenge to verify domain ownership
4. Nginx Ingress serves the challenge response
5. Upon successful validation, Let's Encrypt issues the certificate
6. Cert-manager stores the certificate in the specified TLS secret
7. Nginx Ingress uses the certificate for HTTPS traffic

### Verification Commands

```bash
# Check cert-manager pods
kubectl --kubeconfig ~/.kube/k3s-psychz-config -n cert-manager get pods

# View certificates
kubectl --kubeconfig ~/.kube/k3s-psychz-config get certificates -A

# Check certificate details
kubectl --kubeconfig ~/.kube/k3s-psychz-config -n <namespace> describe certificate <name>

# View cert-manager logs
kubectl --kubeconfig ~/.kube/k3s-psychz-config -n cert-manager logs -l app.kubernetes.io/name=cert-manager -f

# Check certificate ready status
kubectl --kubeconfig ~/.kube/k3s-psychz-config get certificates -A -o wide
```

## Infrastructure Components

### Cert-manager

- **Purpose**: Automates TLS certificate issuance and renewal
- **Deployment**: 3 components (cert-manager, webhook, cainjector)
- **Health Checks**: Flux waits for all 3 deployments to be ready before proceeding
- **Timeout**: 5 minutes for full deployment
- **Integration**: Works with Nginx Ingress via HTTP-01 challenge

### Nginx Ingress Controller

- **Purpose**: Routes HTTP/HTTPS traffic to services
- **IngressClass**: `nginx`
- **Integration**: Works with cert-manager for TLS termination
- **Depends On**: cert-manager (must be fully operational first)

### Flux Notifications

- **Purpose**: Sends Flux reconciliation events to Discord
- **Location**: [apps/infra/flux-notifications/](apps/infra/flux-notifications/)
- **Provider**: Discord webhook integration
- **Events**: Alert on Flux kustomization and HelmRelease events

## GitHub Webhook Integration

The repository is configured with GitHub webhooks for instant reconciliation instead of waiting for the 10-minute polling interval.

### Webhook Configuration
- **Endpoint**: `https://flux-webhook.amajor.cloud/hook/<receiver-id>`
- **Receiver**: [apps/base/flux-webhook/](apps/base/flux-webhook/)
- **Events**: Push events to `main` branch trigger immediate Flux reconciliation
- **Security**: NetworkPolicy restricts access, encrypted token in SealedSecret

For setup instructions and troubleshooting, see [apps/base/flux-webhook/README.md](apps/base/flux-webhook/README.md).

## Deployed Applications

| Application | Description | Features |
|------------|-------------|----------|
| **flux-webhook** | GitHub webhook receiver | Instant reconciliation, NetworkPolicy security |
| **uptime-kuma** | Uptime monitoring | PersistentVolume storage at `uptime.amajor.cloud` |
| **speedtest** | LibreSpeed speed test | Self-hosted speed testing at `speedtest.amajor.cloud` |
| **tickerlake** | Ticker application | Custom application |
| **hvcwatch** | HVC watch service | Encrypted secrets via SealedSecrets |
| **stockchartsalerts** | Stock chart alerts | Encrypted secrets, monitoring alerts |

All applications are accessible via `<app-name>.amajor.cloud` with automatic HTTPS.

## Important Notes

- **DO NOT edit** [clusters/selfhosted/flux-system/gotk-components.yaml](clusters/selfhosted/flux-system/gotk-components.yaml) or [gotk-sync.yaml](clusters/selfhosted/flux-system/gotk-sync.yaml) - these are auto-generated by Flux
- **DO NOT push directly to `main`** - always use feature branches and PRs unless explicitly instructed otherwise
- **DO NOT run git push** without user permission - the user will handle pushing to remote
- Changes to the `main` branch are automatically applied to the cluster (immediately via webhook, or within 10 minutes via polling)
- Renovate is configured to auto-merge dependency updates (see [renovate.json](renovate.json))
- The repository uses SSH authentication for Flux (secret: `flux-system` in `flux-system` namespace)
- All applications use the `*.amajor.cloud` domain with standard Kubernetes Ingress resources
- TLS certificates are managed by Cert-manager using Let's Encrypt HTTP-01 challenge
- Secrets are encrypted using Sealed Secrets before being committed to Git
- **Always use sha256 hashes** in this repository when deploying containers

## K3s Installation

When installing K3s for this cluster, **disable the built-in Traefik** since this repository manages Nginx Ingress via Flux:

```bash
curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC="server --disable traefik" sh -s -
```

This prevents conflicts between k3s's built-in Traefik and the GitOps-managed Nginx Ingress.

## Troubleshooting

### Sealed Secrets

If a SealedSecret fails to decrypt with "no key could decrypt secret", the sealed secret was encrypted with a different controller's key. Re-seal the secret:

```bash
# Get the current sealed-secrets controller public key and re-encrypt
kubectl --kubeconfig ~/.kube/k3s-psychz-config create secret generic <secret-name> \
  --from-literal=<key>=<value> \
  --namespace=<namespace> \
  --dry-run=client -o yaml | \
kubeseal --kubeconfig ~/.kube/k3s-psychz-config \
  --controller-name=sealed-secrets \
  --controller-namespace=sealed-secrets \
  --format=yaml > <output-file>.yaml
```

### Certificate Issues

If certificates are not being issued:

```bash
# Check cert-manager logs for errors
kubectl --kubeconfig ~/.kube/k3s-psychz-config -n cert-manager logs -l app.kubernetes.io/name=cert-manager --tail=100

# Check certificate status
kubectl --kubeconfig ~/.kube/k3s-psychz-config -n <namespace> describe certificate <name>

# Check certificate requests
kubectl --kubeconfig ~/.kube/k3s-psychz-config get certificaterequests -A

# Verify ClusterIssuer is ready
kubectl --kubeconfig ~/.kube/k3s-psychz-config get clusterissuer
```

Common issues:
- **HTTP-01 challenge fails**: Ensure port 80 is accessible from the internet for Let's Encrypt validation
- **Certificate stuck in pending**: Check cert-manager logs and CertificateRequest events
- **Rate limits**: Use `letsencrypt-staging` for testing to avoid production rate limits

### Nginx Ingress Issues

```bash
# Check Nginx Ingress controller pods
kubectl --kubeconfig ~/.kube/k3s-psychz-config -n nginx-ingress get pods

# View Nginx Ingress logs
kubectl --kubeconfig ~/.kube/k3s-psychz-config -n nginx-ingress logs -l app.kubernetes.io/name=nginx-ingress -f

# Check Ingress resources
kubectl --kubeconfig ~/.kube/k3s-psychz-config get ingress -A
```

### Flux Reconciliation Issues

```bash
# Check Flux logs for errors
flux logs --kubeconfig ~/.kube/k3s-psychz-config --level=error --follow

# Check kustomization status
flux get kustomizations --kubeconfig ~/.kube/k3s-psychz-config

# Describe a failing kustomization
kubectl --kubeconfig ~/.kube/k3s-psychz-config -n flux-system describe kustomization <name>

# Force reconciliation
flux reconcile kustomization apps --kubeconfig ~/.kube/k3s-psychz-config
```
